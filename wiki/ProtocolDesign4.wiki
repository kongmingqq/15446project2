#summary An overall description of the protocol design
#labels Phase-Design

=Assumptions:=
 * Vector format: Vector*<Object*> sampleVector = new Vector();
Object contains two element: data type(String), data content(Java Bean)
 * C: client / S: server
----
=Normal Case: (the type could be only one character)=
==Stage1 Initialization==
Clients get to the initialization status. (e.g ID) from the server. Once the clients receive INIT message from the server, it proceeds to the voting stage.
 * C -> S: INIT, InvitationBean
 * S -> C: INIT, InvitationBean with ID
Server sends SMS to the client according to the phone number, client side application is called when it received the message.
==Stage2 Voting stage==
After this stage finished, server start listening to the map message sent from the client. And when the client received the SMS, it starts communicating with server.
 * C -> S: VOTE, VoteBean
Server waits for 1. All the node finished voting. OR 2. Time out to start the voting stage.
 * S -> C: VOTE, VoteBean
Server calculates the voting result and send the result back the all the clients.
==Stage3 Tracing stage==
 * C -> S: TRACE:LOC, LocationBean
Each client sends its location info to the server.
 * S -> C (only when requested): TRACE:AGGLOC, AggLocationBean
Server sends back aggregated location info to client.
Notice that the beans in two ways are different, but the type name is the same.
* BeanVector and Protocol class implements this protocol.
==Stage4 Terminate (Client requests)==
 * C -> S: TERM, TermBean
 * S -> C: TERM
==Stage5 Terminate (Server requests)==
 * S -> C: TERM, TermBean
----
=Additional Explanations:=
 # In each stage, server only deals the message with the specified data type. For example, in the Voting stage, server will only accept the vector with VOTE in the first element, and drops all other messages.